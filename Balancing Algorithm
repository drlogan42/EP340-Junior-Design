
#include <AccelStepper.h>
#include <MultiStepper.h>
#include <TouchScreen.h>

// === Pin Definitions ===
#define MOTOR_A_IN1  2
#define MOTOR_A_IN2  3
#define MOTOR_A_IN3  4
#define MOTOR_A_IN4  5

#define MOTOR_B_IN1  6
#define MOTOR_B_IN2  7
#define MOTOR_B_IN3  8
#define MOTOR_B_IN4  9

#define MOTOR_C_IN1 10
#define MOTOR_C_IN2 11
#define MOTOR_C_IN3 12
#define MOTOR_C_IN4 13

#define XP A1
#define XM A2
#define YP A3
#define YM A0

TouchScreen ts = TouchScreen(XP, YP, XM, YM, 480);

// === Calibration ===
#define TS_MINX 70
#define TS_MAXX 510
#define TS_MINY 470
#define TS_MAXY 930

#define SCREEN_WIDTH_MM 130
#define SCREEN_HEIGHT_MM 172

// === Stepper and Control Constants ===
#define STEPS_PER_REV 400
#define MAX_MOTOR_SPEED 800
#define MOTOR_ACCELERATION 300

AccelStepper stepperA(AccelStepper::HALF4WIRE, MOTOR_A_IN1, MOTOR_A_IN2, MOTOR_A_IN3, MOTOR_A_IN4);
AccelStepper stepperB(AccelStepper::HALF4WIRE, MOTOR_B_IN1, MOTOR_B_IN2, MOTOR_B_IN3, MOTOR_B_IN4);
AccelStepper stepperC(AccelStepper::HALF4WIRE, MOTOR_C_IN1, MOTOR_C_IN2, MOTOR_C_IN3, MOTOR_C_IN4);

MultiStepper steppers;

// === PID Parameters ===
float kp = -1000;
float ki = 0.1;
float kd = 0.5;

float lastErrorX = 0, lastErrorY = 0;
float integralX = 0, integralY = 0;
unsigned long lastTime = 0;

// === System State ===
bool systemReady = false;
long initialOffset[3] = {0, 0, 0};
long motorTargets[3] = {0, 0, 0};

void setup() {
  Serial.begin(9600);
  Serial.println("Ball Balancer setup started...");

  stepperA.setMaxSpeed(MAX_MOTOR_SPEED);
  stepperB.setMaxSpeed(MAX_MOTOR_SPEED);
  stepperC.setMaxSpeed(MAX_MOTOR_SPEED);

  stepperA.setAcceleration(MOTOR_ACCELERATION);
  stepperB.setAcceleration(MOTOR_ACCELERATION);
  stepperC.setAcceleration(MOTOR_ACCELERATION);

  steppers.addStepper(stepperA);
  steppers.addStepper(stepperB);
  steppers.addStepper(stepperC);

  long initialLift[3] = {100, 100, 100};
  steppers.moveTo(initialLift);
  steppers.runSpeedToPosition();

  Serial.println("Platform lifted. Tap the screen to begin...");
}

void loop() {
  if (!systemReady) {
    TSPoint p = ts.getPoint();
    pinMode(XP, OUTPUT); pinMode(XM, OUTPUT); pinMode(YP, OUTPUT); pinMode(YM, OUTPUT);
    if (p.z > 10) {
      initialOffset[0] = stepperA.currentPosition();
      initialOffset[1] = stepperB.currentPosition();
      initialOffset[2] = stepperC.currentPosition();
      systemReady = true;
      lastTime = millis();
      Serial.println("Touch detected. Starting control loop...");
    }
    return;
  }

  int x_mm = 0, y_mm = 0;
  getBallPosition(x_mm, y_mm);
  if (x_mm == 0 && y_mm == 0) return;

  float errorX = (SCREEN_WIDTH_MM / 2.0) - x_mm;
  float errorY = (SCREEN_HEIGHT_MM / 2.0) - y_mm;

  unsigned long now = millis();
  float dt = (now - lastTime) / 1000.0;
  lastTime = now;

  float tiltX = computePID(errorX, lastErrorX, integralX, dt);
  float tiltY = computePID(errorY, lastErrorY, integralY, dt);

  tiltX = constrain(tiltX, -30, 30);
  tiltY = constrain(tiltY, -30, 30);

  static unsigned long lastUpdate = 0;
  if (millis() - lastUpdate > 100) {
    computeInverseKinematics(tiltX, tiltY, motorTargets);
    steppers.moveTo(motorTargets);
    lastUpdate = millis();
  }

  steppers.run();

  Serial.print("Ball X: "); Serial.print(x_mm);
  Serial.print(" | Y: "); Serial.print(y_mm);
  Serial.print(" || Error X: "); Serial.print(errorX);
  Serial.print(" | Error Y: "); Serial.print(errorY);
  Serial.print(" || PID X: "); Serial.print(tiltX);
  Serial.print(" | PID Y: "); Serial.println(tiltY);
  Serial.print("Target A: "); Serial.print(motorTargets[0]);
  Serial.print(" | B: "); Serial.print(motorTargets[1]);
  Serial.print(" | C: "); Serial.println(motorTargets[2]);

 // delay(10);
}

void getBallPosition(int &x_mm, int &y_mm) {
  TSPoint p = ts.getPoint();
  pinMode(XP, OUTPUT); pinMode(XM, OUTPUT); pinMode(YP, OUTPUT); pinMode(YM, OUTPUT);
  if (p.z > 10) {
    x_mm = map(p.x, TS_MINX, TS_MAXX, 0, SCREEN_WIDTH_MM);
    y_mm = map(p.y, TS_MINY, TS_MAXY, 0, SCREEN_HEIGHT_MM);
  } else {
    x_mm = 0;
    y_mm = 0;
  }
}

float computePID(float error, float &lastError, float &integral, float dt) {
  integral += error * dt;
  float derivative = (error - lastError) / dt;
  lastError = error;
  return (kp * error) + (ki * integral) + (kd * derivative);
}

void computeInverseKinematics(float tiltX, float tiltY, long targets[3]) {
  const float cos60 = 0.5;
  const float sin60 = 0.866;
  float z1 = -cos60 * tiltX + sin60 * tiltY;
  float z2 = tiltX;
  float z3 = -cos60 * tiltX - sin60 * tiltY;
  float scale = 10.0;
  targets[0] = initialOffset[0] + z1 * scale;
  targets[1] = initialOffset[1] + z2 * scale;
  targets[2] = initialOffset[2] + z3 * scale;
}
