#include <AccelStepper.h>
#include <MultiStepper.h>
#include <TouchScreen.h>

// --- Motor Pins ---
#define MOTOR_A_IN1  2
#define MOTOR_A_IN2  3
#define MOTOR_A_IN3  4
#define MOTOR_A_IN4  5

#define MOTOR_B_IN1  6
#define MOTOR_B_IN2  7
#define MOTOR_B_IN3  8
#define MOTOR_B_IN4  9

#define MOTOR_C_IN1 10
#define MOTOR_C_IN2 11
#define MOTOR_C_IN3 12
#define MOTOR_C_IN4 13

// --- Touchscreen Pins ---
#define XP A1
#define XM A2
#define YP A3
#define YM A0

TouchScreen ts = TouchScreen(XP, YP, XM, YM, 480);  // Resistance from multimeter

// --- Touchscreen Calibration ---
#define TS_MINX 70
#define TS_MAXX 510
#define TS_MINY 470
#define TS_MAXY 930

#define SCREEN_WIDTH_MM 130
#define SCREEN_HEIGHT_MM 172

// --- Stepper Settings ---
#define STEPS_PER_REV 400
#define MAX_MOTOR_SPEED 300
#define MOTOR_ACCELERATION 100

AccelStepper stepperA(AccelStepper::HALF4WIRE, MOTOR_A_IN1, MOTOR_A_IN2, MOTOR_A_IN3, MOTOR_A_IN4);
AccelStepper stepperB(AccelStepper::HALF4WIRE, MOTOR_B_IN1, MOTOR_B_IN2, MOTOR_B_IN3, MOTOR_B_IN4);
AccelStepper stepperC(AccelStepper::HALF4WIRE, MOTOR_C_IN1, MOTOR_C_IN2, MOTOR_C_IN3, MOTOR_C_IN4);

MultiStepper steppers;

// --- Initialization State ---
bool systemReady = false;
long initialOffset[3] = {0, 0, 0};

// PID Constants
float kp = 2.0;
float ki = 0.0;
float kd = 0.5;

float lastErrorX = 0, lastErrorY = 0;
float integralX = 0, integralY = 0;
unsigned long lastTime = 0;

//SETUP
void setup() {
  Serial.begin(9600);
  Serial.println("Ball Balancer setup started...");

  // Motor setup
  stepperA.setMaxSpeed(MAX_MOTOR_SPEED);
  stepperB.setMaxSpeed(MAX_MOTOR_SPEED);
  stepperC.setMaxSpeed(MAX_MOTOR_SPEED);

  stepperA.setAcceleration(MOTOR_ACCELERATION);
  stepperB.setAcceleration(MOTOR_ACCELERATION);
  stepperC.setAcceleration(MOTOR_ACCELERATION);

  steppers.addStepper(stepperA);
  steppers.addStepper(stepperB);
  steppers.addStepper(stepperC);

  // Raise platform slightly
  long initialLift[3] = {100, 100, 100};
  steppers.moveTo(initialLift);
  steppers.runSpeedToPosition();

  Serial.println("Platform lifted. Tap the screen to begin tracking...");
}

//LOOP
void loop() {
  // Wait for user tap to start
  if (!systemReady) {
    TSPoint p = ts.getPoint();

    pinMode(XP, OUTPUT);
    pinMode(XM, OUTPUT);
    pinMode(YP, OUTPUT);
    pinMode(YM, OUTPUT);

    if (p.z > 10) {
      initialOffset[0] = stepperA.currentPosition();
      initialOffset[1] = stepperB.currentPosition();
      initialOffset[2] = stepperC.currentPosition();

      systemReady = true;
      Serial.println("Touch detected. Starting position tracking...");
    }
    return;
  }

// --- Ball Position Tracking ---
int x_mm = 0, y_mm = 0;
getBallPosition(x_mm, y_mm);

if (x_mm == 0 && y_mm == 0) return;  // No touch

// --- Compute Error from center ---
float errorX = (SCREEN_WIDTH_MM / 2.0) - x_mm;
float errorY = (SCREEN_HEIGHT_MM / 2.0) - y_mm;

// --- Time delta ---
unsigned long now = millis();
float dt = (now - lastTime) / 1000.0;
lastTime = now;

// --- PID Output: Target tilt angle ---
float tiltX = computePID(errorX, lastErrorX, integralX, dt);
float tiltY = computePID(errorY, lastErrorY, integralY, dt);

// --- Inverse Kinematics (Placeholder) ---
long motorTargets[3];
computeInverseKinematics(tiltX, tiltY, motorTargets);

// --- Print Target Motor Steps ---
Serial.print("Target A: ");
Serial.print(motorTargets[0]);
Serial.print(" | B: ");
Serial.print(motorTargets[1]);
Serial.print(" | C: ");
Serial.println(motorTargets[2]);

// --- Debug Output Only ---
Serial.print("Ball X: ");
Serial.print(x_mm);
Serial.print(" mm | Y: ");
Serial.print(y_mm);
Serial.print(" mm || Error X: ");
Serial.print(errorX);
Serial.print(" | Error Y: ");
Serial.print(errorY);
Serial.print(" || PID X: ");
Serial.print(tiltX);
Serial.print(" | PID Y: ");
Serial.println(tiltY);

//output example
//Ball X: 56 mm | Y: 90 mm || Error X: 9.00 | Error Y: -4.00 || PID X: 18.00 | PID Y: -15.81
//Target A: -261 | B: 1101 | C: 461
//Error is how far ball is from center of each axis
//PID is amount of tilt needed to bring ball back to center

steppers.moveTo(motorTargets);
steppers.runSpeedToPosition();  // Blocking until position is reached

//Debug Step
Serial.print("Stepper A Pos: ");
Serial.print(stepperA.currentPosition());
Serial.print(" | B: ");
Serial.print(stepperB.currentPosition());
Serial.print(" | C: ");
Serial.println(stepperC.currentPosition());

}

// --- Ball Position Reader Function ---
void getBallPosition(int &x_mm, int &y_mm) {
  TSPoint p = ts.getPoint();

  pinMode(XP, OUTPUT);
  pinMode(XM, OUTPUT);
  pinMode(YP, OUTPUT);
  pinMode(YM, OUTPUT);

  if (p.z > 10) {
    x_mm = map(p.x, TS_MINX, TS_MAXX, 0, SCREEN_WIDTH_MM);
    y_mm = map(p.y, TS_MINY, TS_MAXY, 0, SCREEN_HEIGHT_MM);
  } else {
    x_mm = 0;
    y_mm = 0;
  }
}

//Compute PID
float computePID(float error, float &lastError, float &integral, float dt) {
  integral += error * dt;
  float derivative = (error - lastError) / dt;
  lastError = error;
  return (kp * error) + (ki * integral) + (kd * derivative);
}

//Inverse Kinematics
void computeInverseKinematics(float tiltX, float tiltY, long targets[3]) {
  targets[0] = initialOffset[0] + tiltX * 10;  // Motor A
  targets[1] = initialOffset[1] + tiltY * 10;  // Motor B
  targets[2] = initialOffset[2] - tiltX * 10;  // Motor C (example setup)
}



